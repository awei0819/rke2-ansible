---
# RKE2集群完整部署Playbook
- name: 全局变量初始化 - 加载集群配置并共享
  hosts: localhost
  connection: local
  gather_facts: no
  vars_files:
    - ../cluster.yaml
  tasks:
    - name: 绑定全局变量到localhost（所有节点可通过hostvars访问）
      set_fact:
        # 核心修改1：强化变量过滤（清理所有空白字符，不止首尾）
        global_master_arch: "{{ master_arch | trim | replace(' ', '') | replace('\n', '') | replace('\r', '') }}"
        global_worker_arch: "{{ worker_arch | trim | replace(' ', '') | replace('\n', '') | replace('\r', '') }}"
        # 原始local_address本身无端口
        global_local_address: "{{ local_address }}"
        # 处理master列表：去掉每个元素的":端口"部分，只保留IP
        global_master_list: "{{ master | map('regex_replace', ':.*', '') | list }}"
        # 处理worker列表：去掉每个元素的":端口"部分，只保留IP（兼容空列表）
        global_worker_list: "{{ worker | default([]) | map('regex_replace', ':.*', '') | list }}"
        # 其他变量保持不变
        global_data_dir: "{{ data_dir }}"
        global_cni: "{{ cni }}"
        global_master_ingress: "{{ master_ingress }}"
        global_worker_ingress: "{{ worker_ingress }}"
        global_registries: "{{ registries }}"
        # 用dirname过滤器提取data_dir中rke2前面的路径
        base_data_dir: "{{ data_dir | dirname }}"
    
# ========== 前置验证（只在localhost执行） ==========
    - name: 验证cluster.yaml配置
      fail:
        msg: "集群配置中必须包含master节点！当前master列表：{{ global_master_list | default('未定义') }}"
      when: global_master_list is not defined or global_master_list|length == 0

    - name: 验证local_address配置
      fail:
        msg: "cluster.yaml中必须配置local_address！当前值：{{ global_local_address | default('未定义') }}"
      when: global_local_address is not defined or global_local_address == ""
    
    - name: 验证local_address在master列表中
      fail:
        msg: |
          错误：local_address ({{ global_local_address }}) 不在master节点列表中！
          master节点列表: {{ global_master_list }}
      when: global_local_address not in global_master_list
    
    - name: 显示验证通过信息
      debug:
        msg: |
          =========================================
          cluster.yaml 配置验证通过：
          - local_address: {{ global_local_address }} ✓ (在master列表中)
          - master节点数: {{ global_master_list | length }} 个
          - worker节点数: {{ global_worker_list | length }} 个
          - 数据目录: {{ global_data_dir }}
          - CNI: {{ global_cni }}
          =========================================


# ==================== 步骤0: 同步全局变量到所有节点 ====================
- name: 步骤0 - 同步全局变量到所有节点
  hosts: rke2
  gather_facts: yes
  tasks:
    - name: 从localhost同步全局变量
      set_fact:
        global_master_arch: "{{ hostvars['localhost']['global_master_arch'] }}"
        global_worker_arch: "{{ hostvars['localhost']['global_worker_arch'] }}"
        global_local_address: "{{ hostvars['localhost']['global_local_address'] }}"
        global_master_list: "{{ hostvars['localhost']['global_master_list'] }}"
        global_worker_list: "{{ hostvars['localhost']['global_worker_list'] }}"
        global_data_dir: "{{ hostvars['localhost']['global_data_dir'] }}"
        global_cni: "{{ hostvars['localhost']['global_cni'] }}"
        global_master_ingress: "{{ hostvars['localhost']['global_master_ingress'] }}"
        global_worker_ingress: "{{ hostvars['localhost']['global_worker_ingress'] }}"
        global_registries: "{{ hostvars['localhost']['global_registries'] }}"
        base_data_dir: "{{ hostvars['localhost']['base_data_dir'] }}"
    
    - name: 验证变量已同步
      debug:
        msg: |
          节点 {{ inventory_hostname }} 变量同步完成:
          - global_data_dir: {{ global_data_dir }}
          - base_data_dir: {{ base_data_dir }}
          - local_address: {{ global_local_address }}
          - global_master_arch: |{{ global_master_arch }}|  # 竖线验证无空白


# ==================== 步骤1: 准备目录和解压安装包（复用全局变量） ====================
- name: 步骤1 - 准备目录和解压安装包
  hosts: rke2
  vars:
    # 从全局变量读取，避免重复定义
    rke2_config_dir: /etc/rancher/rke2
    rke2_data_dir: "{{ global_data_dir }}"
    rke2_artifacts_dir: "{{ base_data_dir }}/rke2-artifacts"
    rke2_images_dir: "{{ rke2_data_dir }}/agent/images"
    # 强化架构变量过滤（兜底+全空白清理）
    artifacts_arch: >-
      {% if 'rke2-masters' in group_names %}
        {{ global_master_arch | trim | replace(' ', '') | replace('\n', '') | replace('\r', '') }}
      {% elif 'rke2-workers' in group_names %}
        {{ global_worker_arch | trim | replace(' ', '') | replace('\n', '') | replace('\r', '') }}
      {% else %}
        "amd64"  # 兜底默认值，避免空值
      {% endif %}
    packages_abs_dir: "../packages"

  tasks:
    # 在控制节点查找匹配的安装包（解决通配符问题）
    - name: 在控制节点查找RKE2安装包
      find:
        path: "{{ packages_abs_dir }}"
        patterns: "rke2-artifacts-{{ artifacts_arch | trim }}*.tgz"  # 匹配架构开头的tgz包
        file_type: file
        use_regex: no
      register: found_tarballs
      delegate_to: localhost  # 安装包在控制节点，本地查找
      failed_when: found_tarballs.matched == 0  # 没找到文件直接报错，提示用户

    # 新增：设置实际的安装包绝对路径
    - name: 设置安装包绝对路径
      set_fact:
        real_tarball_path: "{{ found_tarballs.files[0].path }}"

    # 新增：调试打印关键信息（便于排查）
    - name: 调试 - 打印安装包匹配结果
      debug:
        msg:
          - "架构值：|{{ artifacts_arch }}|"
          - "安装包目录：{{ packages_abs_dir }}"
          - "匹配到的安装包：{{ real_tarball_path }}"
          - "匹配到的文件数：{{ found_tarballs.matched }}"

    - name: 创建RKE2目录
      file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
        owner: root
        group: root
      loop:
        - "{{ rke2_config_dir }}"
        - "{{ rke2_data_dir }}"
        - "{{ rke2_artifacts_dir }}"
        - "{{ rke2_images_dir }}"
  
    - name: 检查artifacts是否已存在
      stat:
        path: "{{ rke2_artifacts_dir }}/install.sh"
      register: artifact_check
  
    - name: 显示当前状态
      debug:
        msg: "节点 {{ inventory_hostname }} - Artifacts存在: {{ artifact_check.stat.exists }}"
  
    # 使用实际找到的绝对路径解压
    - name: 解压artifacts到 {{ base_data_dir }}
      unarchive:
        src: "{{ real_tarball_path }}"  # 用find找到的具体路径
        dest: "{{ base_data_dir }}"
        remote_src: no
        creates: "{{ rke2_artifacts_dir }}/install.sh"
      when: not artifact_check.stat.exists
  
    - name: 复制rke2镜像文件到images目录
      copy:
        src: "{{ rke2_artifacts_dir }}/rke2-images.linux-amd64.tar.zst"
        dest: "{{ rke2_images_dir }}/"
        remote_src: yes
        mode: "0644"
        owner: root
        group: root
        backup: yes
      ignore_errors: yes  # 兼容不同版本包名差异
    
    - name: 复制calico镜像文件到images目录
      copy:
        src: "{{ rke2_artifacts_dir }}/rke2-images-calico.linux-amd64.tar.zst"
        dest: "{{ rke2_images_dir }}/"
        remote_src: yes
        mode: "0644"
        owner: root
        group: root
        backup: yes
      ignore_errors: yes  # 兼容不同版本包名差异
  
    - name: 验证结果
      shell: |
        echo "=== 节点: {{ inventory_hostname }} ==="
        echo "基础数据目录: {{ base_data_dir }}"
        echo "RKE2 artifacts目录: {{ rke2_artifacts_dir }}"
        echo "RKE2 images目录: {{ rke2_images_dir }}"
        echo "Artifacts目录中的文件:"
        ls -lh "{{ rke2_artifacts_dir }}/" 2>/dev/null | head -10 || echo "未找到文件"
        echo "Images目录中的文件:"
        ls -lh "{{ rke2_images_dir }}/" 2>/dev/null | head -10 || echo "未找到文件"
        echo "Calico images相关文件:"
        ls -lh "{{ rke2_artifacts_dir }}/" | grep calico || echo "无Calico镜像文件"
      register: verify_result
      changed_when: false
  
    - name: 显示验证结果
      debug:
        msg: "{{ verify_result.stdout_lines }}"

# ==================== 步骤2: 为local_address节点准备证书 ====================
- name: 步骤2 - 使用原始脚本生成RKE2证书
  hosts: rke2-masters
  gather_facts: yes
  vars:
    rke2_data_dir: "{{ hostvars['localhost']['global_data_dir'] }}"
  
  tasks:
    - name: 检查当前节点是否是 local_address
      set_fact:
        is_local_address: "{{ ansible_facts['default_ipv4']['address'] == hostvars['localhost']['global_local_address'] or inventory_hostname == hostvars['localhost']['global_local_address'] }}"
    
    - name: 如果不是local_address则跳过
      meta: end_host
      when: not is_local_address
    
    - name: 执行原始脚本生成证书
      shell: |
        set -e  # 脚本执行出错时立即退出，避免后续无效操作

        ###########################################################################
        # 1. 配置 RKE2 证书有效期环境变量（仅首次配置，已存在则跳过）
        ###########################################################################
        ENV_FILE="/etc/default/rke2-server"
        ENV_KEY="CATTLE_NEW_SIGNED_CERT_EXPIRATION_DAYS"
        ENV_VALUE="36500"

        if [ ! -f "$ENV_FILE" ]; then
            echo "=== 首次创建 RKE2 环境变量文件：$ENV_FILE ==="
            echo "$ENV_KEY=$ENV_VALUE" > "$ENV_FILE"
        elif ! grep -q "^$ENV_KEY=$ENV_VALUE" "$ENV_FILE"; then
            echo "=== 更新 RKE2 环境变量：$ENV_KEY 为 $ENV_VALUE ==="
            # 先删除旧配置（若存在），再添加新配置
            sed -i "/^$ENV_KEY=/d" "$ENV_FILE"
            echo "$ENV_KEY=$ENV_VALUE" >> "$ENV_FILE"
        else
            echo "=== RKE2 环境变量 $ENV_KEY=$ENV_VALUE 已存在，跳过 ==="
        fi

        ###########################################################################
        # 2. 创建证书目录（与 RKE2 数据目录对应，已存在则跳过）
        ###########################################################################
        DATA_DIR="{{ rke2_data_dir }}"
        CERT_DIR="$DATA_DIR/server/tls"
        ETCD_CERT_DIR="$CERT_DIR/etcd"

        if [ ! -d "$ETCD_CERT_DIR" ]; then
            echo "=== 创建证书目录：$ETCD_CERT_DIR ==="
            mkdir -p "$ETCD_CERT_DIR"
            chmod -R 700 "$CERT_DIR"  # 目录权限：仅所有者可读写执行
            echo "=== 证书目录权限设置完成 ==="
        else
            echo "=== 证书目录 $ETCD_CERT_DIR 已存在，跳过 ==="
        fi

        ###########################################################################
        # 3. 自签根 CA 证书（服务器端）：已存在则跳过
        ###########################################################################
        # 服务器 CA 私钥/证书路径
        SERVER_CA_KEY="$CERT_DIR/server-ca.key"
        SERVER_CA_CSR="$CERT_DIR/server-ca.csr"
        SERVER_CA_CRT="$CERT_DIR/server-ca.crt"
        SERVER_CA_NOCHAIN="$CERT_DIR/server-ca.nochain.crt"

        if [ ! -f "$SERVER_CA_CRT" ]; then
            echo "=== 生成服务器 CA 私钥（2048位）==="
            openssl genrsa -out "$SERVER_CA_KEY" 2048
            chmod 600 "$SERVER_CA_KEY"  # 私钥权限：仅所有者可读写

            echo "=== 生成服务器 CA 证书请求（CSR）==="
            openssl req -new -key "$SERVER_CA_KEY" \
                -out "$SERVER_CA_CSR" \
                -subj "/C=CN/ST=Beijing/L=Beijing/O=RKE2/OU=CA/CN=RKE2 Server CA"

            echo "=== 自签服务器 CA 证书（有效期 100 年）==="
            openssl x509 -req -days 36500 \
                -in "$SERVER_CA_CSR" \
                -signkey "$SERVER_CA_KEY" \
                -out "$SERVER_CA_CRT"
            chmod 644 "$SERVER_CA_CRT"  # 证书权限：所有者可读写，其他用户可读

            echo "=== 生成服务器 CA 无链证书（RKE2 要求）==="
            cp "$SERVER_CA_CRT" "$SERVER_CA_NOCHAIN"
            chmod 644 "$SERVER_CA_NOCHAIN"
            echo "=== 服务器 CA 证书生成完成 ==="
        else
            echo "=== 服务器 CA 证书 $SERVER_CA_CRT 已存在，跳过 ==="
        fi

        ###########################################################################
        # 4. 自签客户端 CA 证书：已存在则跳过
        ###########################################################################
        # 客户端 CA 私钥/证书路径
        CLIENT_CA_KEY="$CERT_DIR/client-ca.key"
        CLIENT_CA_CSR="$CERT_DIR/client-ca.csr"
        CLIENT_CA_CRT="$CERT_DIR/client-ca.crt"
        CLIENT_CA_NOCHAIN="$CERT_DIR/client-ca.nochain.crt"

        if [ ! -f "$CLIENT_CA_CRT" ]; then
            echo "=== 生成客户端 CA 私钥（2048位）==="
            openssl genrsa -out "$CLIENT_CA_KEY" 2048
            chmod 600 "$CLIENT_CA_KEY"

            echo "=== 生成客户端 CA 证书请求（CSR）==="
            openssl req -new -key "$CLIENT_CA_KEY" \
                -out "$CLIENT_CA_CSR" \
                -subj "/C=CN/ST=Beijing/L=Beijing/O=RKE2/OU=CA/CN=RKE2 Client CA"

            echo "=== 自签客户端 CA 证书（有效期 100 年）==="
            openssl x509 -req -days 36500 \
                -in "$CLIENT_CA_CSR" \
                -signkey "$CLIENT_CA_KEY" \
                -out "$CLIENT_CA_CRT"
            chmod 644 "$CLIENT_CA_CRT"

            echo "=== 生成客户端 CA 无链证书（RKE2 要求）==="
            cp "$CLIENT_CA_CRT" "$CLIENT_CA_NOCHAIN"
            chmod 644 "$CLIENT_CA_NOCHAIN"
            echo "=== 客户端 CA 证书生成完成 ==="
        else
            echo "=== 客户端 CA 证书 $CLIENT_CA_CRT 已存在，跳过 ==="
        fi

        ###########################################################################
        # 5. 自签 etcd 相关 CA 证书：已存在则跳过
        ###########################################################################
        # 5.1 etcd 服务器 CA
        ETCD_SERVER_KEY="$ETCD_CERT_DIR/server-ca.key"
        ETCD_SERVER_CSR="$ETCD_CERT_DIR/server-ca.csr"
        ETCD_SERVER_CRT="$ETCD_CERT_DIR/server-ca.crt"

        if [ ! -f "$ETCD_SERVER_CRT" ]; then
            echo "=== 生成 etcd 服务器 CA 私钥（2048位）==="
            openssl genrsa -out "$ETCD_SERVER_KEY" 2048
            chmod 600 "$ETCD_SERVER_KEY"

            echo "=== 生成 etcd 服务器 CA 证书请求（CSR）==="
            openssl req -new -key "$ETCD_SERVER_KEY" \
                -out "$ETCD_SERVER_CSR" \
                -subj "/C=CN/ST=Beijing/L=Beijing/O=RKE2/OU=etcd/CN=etcd Server CA"

            echo "=== 自签 etcd 服务器 CA 证书（有效期 100 年）==="
            openssl x509 -req -days 36500 \
                -in "$ETCD_SERVER_CSR" \
                -signkey "$ETCD_SERVER_KEY" \
                -out "$ETCD_SERVER_CRT"
            chmod 644 "$ETCD_SERVER_CRT"
            echo "=== etcd 服务器 CA 证书生成完成 ==="
        else
            echo "=== etcd 服务器 CA 证书 $ETCD_SERVER_CRT 已存在，跳过 ==="
        fi

        # 5.2 etcd 节点间通信 CA
        ETCD_PEER_KEY="$ETCD_CERT_DIR/peer-ca.key"
        ETCD_PEER_CSR="$ETCD_CERT_DIR/peer-ca.csr"
        ETCD_PEER_CRT="$ETCD_CERT_DIR/peer-ca.crt"

        if [ ! -f "$ETCD_PEER_CRT" ]; then
            echo "=== 生成 etcd 节点通信 CA 私钥（2048位）==="
            openssl genrsa -out "$ETCD_PEER_KEY" 2048
            chmod 600 "$ETCD_PEER_KEY"

            echo "=== 生成 etcd 节点通信 CA 证书请求（CSR）==="
            openssl req -new -key "$ETCD_PEER_KEY" \
                -out "$ETCD_PEER_CSR" \
                -subj "/C=CN/ST=Beijing/L=Beijing/O=RKE2/OU=etcd/CN=etcd Peer CA"

            echo "=== 自签 etcd 节点通信 CA 证书（有效期 100 年）==="
            openssl x509 -req -days 36500 \
                -in "$ETCD_PEER_CSR" \
                -signkey "$ETCD_PEER_KEY" \
                -out "$ETCD_PEER_CRT"
            chmod 644 "$ETCD_PEER_CRT"
            echo "=== etcd 节点通信 CA 证书生成完成 ==="
        else
            echo "=== etcd 节点通信 CA 证书 $ETCD_PEER_CRT 已存在，跳过 ==="
        fi

        ###########################################################################
        # 6. 生成 request-header CA 证书：已存在则跳过
        ###########################################################################
        REQ_HEADER_KEY="$CERT_DIR/request-header-ca.key"
        REQ_HEADER_CSR="$CERT_DIR/request-header-ca.csr"
        REQ_HEADER_CRT="$CERT_DIR/request-header-ca.crt"

        if [ ! -f "$REQ_HEADER_CRT" ]; then
            echo "=== 生成 request-header CA 私钥（2048位）==="
            openssl genrsa -out "$REQ_HEADER_KEY" 2048

            echo "=== 生成 request-header CA 证书请求（CSR）==="
            openssl req -new -key "$REQ_HEADER_KEY" \
                -out "$REQ_HEADER_CSR" \
                -subj "/C=CN/ST=Beijing/L=Beijing/O=RKE2/OU=CA/CN=RKE2 Request-Header CA"

            echo "=== 自签 request-header CA 证书（有效期 100 年）==="
            openssl x509 -req -days 36500 \
                -in "$REQ_HEADER_CSR" \
                -signkey "$REQ_HEADER_KEY" \
                -out "$REQ_HEADER_CRT"

            echo "=== 设置 request-header CA 权限（私钥 600，证书 644）==="
            chmod 600 "$REQ_HEADER_KEY"
            chmod 644 "$REQ_HEADER_CRT"
            echo "=== request-header CA 证书生成完成 ==="
        else
            echo "=== request-header CA 证书 $REQ_HEADER_CRT 已存在，跳过 ==="
        fi

        ###########################################################################
        # 最终验证：检查关键证书是否齐全
        ###########################################################################
        echo -e "\n=== 关键证书文件检查 ==="
        KEY_FILES=("$SERVER_CA_KEY" "$CLIENT_CA_KEY" "$ETCD_SERVER_KEY" "$ETCD_PEER_KEY" "$REQ_HEADER_KEY")
        CRT_FILES=("$SERVER_CA_CRT" "$CLIENT_CA_CRT" "$ETCD_SERVER_CRT" "$ETCD_PEER_CRT" "$REQ_HEADER_CRT")

        all_exists=true
        for file in "${KEY_FILES[@]}" "${CRT_FILES[@]}"; do
            if [ ! -f "$file" ]; then
                echo "❌ 缺失关键文件：$file"
                all_exists=false
            else
                echo "✅ 存在：$file"
            fi
        done

        if $all_exists; then
            echo -e "\n=== 所有证书生成/检查完成！可继续部署 RKE2 集群 ==="
        else
            echo -e "\n❌ 部分关键文件缺失，请检查脚本执行日志或重新运行脚本！"
            exit 1
        fi

        echo -e "\n=== 证书有效期检查 ==="
        for cert in $(find "$CERT_DIR" -name "*.crt"); do
            echo -e "\n=== 证书文件：$cert ==="
            openssl x509 -in "$cert" -noout -dates
        done
        
        echo -e "\n=== 脚本执行完成 ==="
      args:
        executable: /bin/bash
      register: cert_gen_result
    
    - name: 显示证书生成结果
      debug:
        msg: |
          =========================================
          证书生成结果 - 节点: {{ inventory_hostname }}
          =========================================
          生成状态: {% if cert_gen_result.rc == 0 %}✅ 成功{% else %}❌ 失败 - 退出码: {{ cert_gen_result.rc }}{% endif %}
          证书目录: {{ rke2_data_dir }}/server/tls
          =========================================

    - name: 显示证书生成输出
      debug:
        msg: "{{ cert_gen_result.stdout_lines }}"
      when: cert_gen_result.stdout is defined


# ==================== 步骤3: 创建配置文件 ====================
- name: 步骤3 - 生成RKE2配置文件
  hosts: rke2
  gather_facts: yes
  vars:
    rke2_config_dir: /etc/rancher/rke2
    rke2_data_dir: "{{ global_data_dir }}"
    first_master: "{{ global_local_address }}"
  
  tasks:
    - name: 创建RKE2配置目录
      file:
        path: "{{ rke2_config_dir }}"
        state: directory
        mode: 0755
      
    - name: 为所有节点生成registries.yaml
      copy:
        content: |
          {% if global_registries is defined and global_registries %}
          mirrors:
          {% for registry, config in global_registries.mirrors.items() %}
            {{ registry }}:
              endpoint:
          {% for endpoint in config.endpoint %}
                - {{ endpoint }}
          {% endfor %}
          {% endfor %}
 
          configs:
          {% for registry, config in global_registries.configs.items() %}
            {{ registry }}:
              auth:
                username: "{{ config.auth.username }}"
                password: "{{ config.auth.password }}"
              tls:
                insecure_skip_verify: {{ config.tls.insecure_skip_verify | lower }}
          {% endfor %}
          {% else %}
          {}
          {% endif %}
        dest: "{{ rke2_config_dir }}/registries.yaml"
        mode: 0640
      
    - name: 从facts获取实际主机名
      set_fact:
        node_hostname: "{{ ansible_facts['hostname'] }}"
    
    - name: 判断节点类型（通过主机组）
      set_fact:
        is_first_master: "{{ inventory_hostname == first_master }}"
        is_master: "{{ 'rke2-masters' in group_names }}"
        is_worker: "{{ 'rke2-workers' in group_names }}"
    
    - name: 显示节点类型判断结果
      debug:
        msg: |
          节点 {{ inventory_hostname }} 类型判断:
          主机组: {{ group_names }}
          主机名: {{ node_hostname }}
          是否第一个master: {{ is_first_master }}
          是否master节点: {{ is_master }}
          是否worker节点: {{ is_worker }}"
    
    - name: 为每个节点生成config.yaml (不含token，等待master1生成)
      copy:
        content: |
          # Global settings
          write-kubeconfig-mode: "0600"
          cni: {{ global_cni }}
          data-dir: {{ rke2_data_dir }}
          private-registry: "/etc/rancher/rke2/registries.yaml"
          
          # Node name - using actual hostname
          node-name: {{ node_hostname }}
          
          {% if is_master %}
            {% if is_first_master %}
          # Master1 specific settings
          tls-san:
            - {{ first_master }}
            - {{ node_hostname }}
          etcd-snapshot-retention: 10
          etcd-arg:
            - "--listen-metrics-urls=http://0.0.0.0:2381"
          kube-proxy-arg:
            - "--metrics-bind-address=0.0.0.0:10249"
          kube-controller-manager-arg:
            - "--bind-address=0.0.0.0"
          kube-scheduler-arg:
            - "--bind-address=0.0.0.0"
            {% else %}
          # Additional master nodes
          server: https://{{ first_master }}:9345
          tls-san:
            - {{ inventory_hostname }}
            - {{ node_hostname }}
          kube-proxy-arg:
            - "--metrics-bind-address=0.0.0.0:10249"
            {% endif %}
          {% elif is_worker %}
          # Worker nodes
          server: https://{{ first_master }}:9345
          kube-proxy-arg:
            - "--metrics-bind-address=0.0.0.0:10249"
          {% endif %}
          
          {# Ingress配置逻辑 #}
          {% if global_master_ingress == false and is_master %}
          # Disable ingress on master node
          disable: rke2-ingress-nginx
          {% endif %}
          {% if global_worker_ingress == false and is_worker %}
          # Disable ingress on worker node
          disable: rke2-ingress-nginx
          {% endif %}
        dest: "{{ rke2_config_dir }}/config.yaml"
        mode: 0600
      
    - name: 验证生成的配置
      debug:
        msg: |
          为 {{ inventory_hostname }} 生成的配置
          实际主机名: {{ node_hostname }}
          节点类型: {% if is_master %}Master{% elif is_worker %}Worker{% else %}Unknown{% endif %}
          是否是第一个master: {{ is_first_master }}
          Ingress状态: 
            {% if is_master %}
              Master: {{ global_master_ingress }} ({% if global_master_ingress == false %}已禁用{% else %}已启用{% endif %})
            {% elif is_worker %}
              Worker: {{ global_worker_ingress }} ({% if global_worker_ingress == false %}已禁用{% else %}已启用{% endif %})
            {% endif %}"


# ==================== 步骤4: 启动第一个master节点（local_address） ====================
- name: 步骤4 - 启动第一个master节点（local_address）
  hosts: rke2-masters
  vars:
    rke2_config_dir: /etc/rancher/rke2
    rke2_data_dir: "{{ global_data_dir }}"
    rke2_artifacts_dir: "{{ base_data_dir }}/rke2-artifacts"
    first_master: "{{ global_local_address }}"
  
  pre_tasks:
    - name: 检查当前节点是否是 local_address
      set_fact:
        is_local_address: "{{ inventory_hostname == global_local_address }}"
    
    - name: 如果不是local_address则跳过整个play
      meta: end_host
      when: not is_local_address
  
  tasks:

    - name: 检查RKE2是否已安装
      stat:
        path: "{{ rke2_data_dir }}/bin/rke2"
      register: rke2_installed

    - name: 安装第一个master节点
      shell: |
        cd {{ rke2_artifacts_dir }}
        export INSTALL_RKE2_ARTIFACT_PATH={{ rke2_artifacts_dir }}
        export INSTALL_RKE2_TYPE=server
        export INSTALL_RKE2_ARCH=amd64
        bash install.sh
      when: not rke2_installed.stat.exists
    
    - name: 启用并启动rke2-server服务
      systemd:
        name: rke2-server
        enabled: yes
        state: started
        daemon_reload: yes
      register: start_result
      retries: 30
      delay: 20
      until: 
        - start_result is succeeded
        - start_result.status.ActiveState is defined
        - start_result.status.ActiveState == "active"
    
    - name: 检查服务状态
      debug:
        msg: "节点 {{ inventory_hostname }} 的rke2-server服务状态: {{ start_result.status.ActiveState | default('unknown') }}"
    
    - name: 等待RKE2完全启动
      shell: |
        timeout 120 bash -c 'until {{ rke2_data_dir }}/bin/kubectl --kubeconfig {{ rke2_config_dir }}/rke2.yaml get nodes 2>/dev/null; do sleep 2; done'
      register: wait_result
      failed_when: false
      changed_when: false
    
    - name: 配置环境变量
      block:
        # 复制kubectl到/usr/bin
        - name: 复制kubectl
          copy:
            src: "{{ rke2_data_dir }}/bin/kubectl"
            dest: /usr/bin/kubectl
            remote_src: yes
            owner: root
            group: root
        
        - name: 给kubectl添加执行权限
          shell: |
            chmod +x /usr/bin/kubectl
          args:
            executable: /bin/bash
        
        # 创建.kube目录（如果不存在）
        - name: 创建.kube目录
          file:
            path: /root/.kube
            state: directory
            mode: 0700
            owner: root
            group: root
        
        # 复制kubeconfig
        - name: 复制kubeconfig
          copy:
            src: "{{ rke2_config_dir }}/rke2.yaml"
            dest: /root/.kube/config
            remote_src: yes
            mode: 0600
            owner: root
            group: root
        
        # 环境变量配置
        - name: 创建rke2.sh环境变量文件（可选，用于其他用户）
          copy:
            dest: /etc/profile.d/rke2.sh
            content: |
              export PATH=$PATH:{{ rke2_data_dir }}/bin
            mode: 0644
        
        - name: 配置ctr命令和crictl
          lineinfile:
            path: /etc/profile
            line: 'alias ctr="{{ rke2_data_dir }}/bin/ctr --address /run/k3s/containerd/containerd.sock --namespace k8s.io"'
        
        - name: 配置CRI_CONFIG_FILE
          lineinfile:
            path: /etc/profile
            line: 'export CRI_CONFIG_FILE={{ rke2_data_dir }}/agent/etc/crictl.yaml'
        
        - name: 配置containerd.sock软链接
          copy:
            dest: /etc/tmpfiles.d/containerd-sock.conf
            content: 'L /run/containerd/containerd.sock - - - - /run/k3s/containerd/containerd.sock'
        
        - name: 使配置立即生效
          shell: systemd-tmpfiles --create /etc/tmpfiles.d/containerd-sock.conf
        
        - name: 验证软链接
          shell: ls -la /run/containerd/
          register: symlink_check
          changed_when: false
        
        - name: 显示软链接状态
          debug:
            msg: "{{ symlink_check.stdout_lines }}"
    
    - name: 显示master1安装完成信息
      debug:
        msg: |
          =========================================
          第一个master节点安装完成!
          节点: {{ inventory_hostname }}
          角色: local_address (第一个master)
          =========================================


# ==================== 步骤5: 更新其他节点的配置文件 ====================
- name: 步骤5 - 从local_address获取token并更新配置
  hosts: rke2
  vars:
    rke2_config_dir: /etc/rancher/rke2
    rke2_data_dir: "{{ global_data_dir }}"
    first_master: "{{ global_local_address }}"
  
  pre_tasks:
    - name: 检查当前节点是否是local_address
      set_fact:
        is_local_address: "{{ inventory_hostname == global_local_address }}"
    
    - name: 如果是local_address则跳过整个play
      meta: end_host
      when: is_local_address
  
  tasks:
    - name: 从local_address节点获取token
      delegate_to: "{{ first_master }}"
      run_once: yes
      shell: cat {{ rke2_data_dir }}/server/node-token
      register: token_result
      ignore_errors: yes
    
    - name: 设置token为变量
      set_fact:
        token_from_master: "{{ token_result.stdout | default('') }}"
      run_once: yes
    
    - name: 验证token是否获取到
      debug:
        msg: "从local_address节点获取的token: {{ token_from_master | default('未获取到') }}"
      run_once: yes
    
    - name: 更新配置文件添加token（master节点）
      blockinfile:
        path: "{{ rke2_config_dir }}/config.yaml"
        block: |
          token: {{ token_from_master }}
          server: https://{{ first_master }}:9345
        insertbefore: "^# Global settings"
        marker: "# {mark} ANSIBLE MANAGED BLOCK - TOKEN"
      when: 
        - token_from_master | length > 0
        - inventory_hostname in global_master_list
    
    - name: 更新配置文件添加token（worker节点）
      blockinfile:
        path: "{{ rke2_config_dir }}/config.yaml"
        block: |
          token: {{ token_from_master }}
          server: https://{{ first_master }}:9345
        insertbefore: "^# Global settings"
        marker: "# {mark} ANSIBLE MANAGED BLOCK - TOKEN"
      when: 
        - token_from_master | length > 0
        - inventory_hostname in global_worker_list
    
    - name: 显示更新后的配置
      shell: head -10 {{ rke2_config_dir }}/config.yaml
      register: config_check
      changed_when: false
      when: token_from_master | length > 0
    
    - name: 显示配置前几行
      debug:
        msg: "{{ config_check.stdout_lines }}"
      when: config_check is defined and config_check.stdout is defined


# ==================== 步骤6: 启动其他master节点 ====================
- name: 步骤6 - 启动其他master节点
  hosts: rke2-masters
  vars:
    rke2_config_dir: /etc/rancher/rke2
    rke2_data_dir: "{{ global_data_dir }}"
    rke2_artifacts_dir: "{{ base_data_dir }}/rke2-artifacts"
    first_master: "{{ global_local_address }}"
  
  pre_tasks:
    - name: 检查当前节点是否是local_address
      set_fact:
        is_local_address: "{{ inventory_hostname == global_local_address }}"
    
    - name: 如果是local_address则跳过整个play
      meta: end_host
      when: is_local_address
  
  tasks:
    - name: 检查RKE2是否已安装
      stat:
        path: "{{ rke2_data_dir }}/bin/rke2"
      register: rke2_installed
    
    - name: 配置 RKE2 证书有效期环境变量
      shell: |
        set -e  # 脚本执行出错时立即退出，避免后续无效操作

        ###########################################################################
        #  配置 RKE2 证书有效期环境变量（仅首次配置，已存在则跳过）
        ###########################################################################
        ENV_FILE="/etc/default/rke2-server"
        ENV_KEY="CATTLE_NEW_SIGNED_CERT_EXPIRATION_DAYS"
        ENV_VALUE="36500"

        if [ ! -f "$ENV_FILE" ]; then
            echo "=== 首次创建 RKE2 环境变量文件：$ENV_FILE ==="
            echo "$ENV_KEY=$ENV_VALUE" > "$ENV_FILE"
        elif ! grep -q "^$ENV_KEY=$ENV_VALUE" "$ENV_FILE"; then
            echo "=== 更新 RKE2 环境变量：$ENV_KEY 为 $ENV_VALUE ==="
            # 先删除旧配置（若存在），再添加新配置
            sed -i "/^$ENV_KEY=/d" "$ENV_FILE"
            echo "$ENV_KEY=$ENV_VALUE" >> "$ENV_FILE"
        else
            echo "=== RKE2 环境变量 $ENV_KEY=$ENV_VALUE 已存在，跳过 ==="
        fi
      args:
        executable: /bin/bash

    - name: 安装其他master节点
      shell: |
        cd {{ rke2_artifacts_dir }}
        export INSTALL_RKE2_ARTIFACT_PATH={{ rke2_artifacts_dir }}
        export INSTALL_RKE2_TYPE=server
        export INSTALL_RKE2_ARCH=amd64
        bash install.sh
      when: not rke2_installed.stat.exists
    
    - name: 启用并启动rke2-server服务
      systemd:
        name: rke2-server
        enabled: yes
        state: started
        daemon_reload: yes
      register: start_result
      retries: 30
      delay: 20
      until: 
        - start_result is succeeded
        - start_result.status.ActiveState is defined
        - start_result.status.ActiveState == "active"
    
    - name: 检查服务状态
      debug:
        msg: "节点 {{ inventory_hostname }} 的rke2-server服务状态: {{ start_result.status.ActiveState | default('unknown') }}"
    
    - name: 配置环境变量
      block:
        - name: 创建rke2.sh环境变量文件
          copy:
            dest: /etc/profile.d/rke2.sh
            content: |
              export PATH=$PATH:{{ rke2_data_dir }}/bin
              export KUBECONFIG={{ rke2_config_dir }}/rke2.yaml
            mode: 0644

        # 复制kubectl到/usr/bin
        - name: 复制kubectl
          copy:
            src: "{{ rke2_data_dir }}/bin/kubectl"
            dest: /usr/bin/kubectl
            remote_src: yes
            owner: root
            group: root
        
        - name: 给kubectl添加执行权限
          shell: |
            chmod +x /usr/bin/kubectl
          args:
            executable: /bin/bash
        
        # 创建.kube目录（如果不存在）
        - name: 创建.kube目录
          file:
            path: /root/.kube
            state: directory
            mode: 0700
            owner: root
            group: root
        
        # 复制kubeconfig
        - name: 复制kubeconfig
          copy:
            src: "{{ rke2_config_dir }}/rke2.yaml"
            dest: /root/.kube/config
            remote_src: yes
            mode: 0600
            owner: root
            group: root

        - name: 配置ctr命令和crictl
          lineinfile:
            path: /etc/profile
            line: 'alias ctr="{{ rke2_data_dir }}/bin/ctr --address /run/k3s/containerd/containerd.sock --namespace k8s.io"'
        
        - name: 配置CRI_CONFIG_FILE
          lineinfile:
            path: /etc/profile
            line: 'export CRI_CONFIG_FILE={{ rke2_data_dir }}/agent/etc/crictl.yaml'
        
        - name: 配置containerd.sock软链接
          copy:
            dest: /etc/tmpfiles.d/containerd-sock.conf
            content: 'L /run/containerd/containerd.sock - - - - /run/k3s/containerd/containerd.sock'
        
        - name: 使配置立即生效
          shell: systemd-tmpfiles --create /etc/tmpfiles.d/containerd-sock.conf
        
        - name: 验证软链接
          shell: ls -la /run/containerd/
          register: symlink_check
          changed_when: false
        
        - name: 显示软链接状态
          debug:
            msg: "{{ symlink_check.stdout_lines }}"
    
    - name: 显示其他master节点安装完成信息
      debug:
        msg: "其他master节点 {{ inventory_hostname }} 安装完成!"

# ==================== 步骤7: 启动worker节点 ====================
- name: 步骤7 - 启动worker节点
  hosts: rke2-workers
  vars:
    rke2_config_dir: /etc/rancher/rke2
    rke2_data_dir: "{{ global_data_dir }}"
    rke2_artifacts_dir: "{{ base_data_dir }}/rke2-artifacts"
    first_master: "{{ global_local_address }}"
  
  tasks:
    - name: 检查RKE2是否已安装
      stat:
        path: "{{ rke2_data_dir }}/bin/rke2"
      register: rke2_installed
    
    - name: 安装worker节点
      shell: |
        cd {{ rke2_artifacts_dir }}
        export INSTALL_RKE2_ARTIFACT_PATH={{ rke2_artifacts_dir }}
        export INSTALL_RKE2_TYPE=agent
        export INSTALL_RKE2_ARCH=amd64
        bash install.sh
      when: not rke2_installed.stat.exists
    
    - name: 启用并启动rke2-agent服务
      systemd:
        name: rke2-agent
        enabled: yes
        state: started
        daemon_reload: yes
      register: start_result
      retries: 30
      delay: 20
      until: 
        - start_result is succeeded
        - start_result.status.ActiveState is defined
        - start_result.status.ActiveState == "active"
    
    - name: 检查服务状态
      debug:
        msg: "节点 {{ inventory_hostname }} 的rke2-agent服务状态: {{ start_result.status.ActiveState | default('unknown') }}"
    
    - name: 配置环境变量
      block:
        - name: 创建rke2.sh环境变量文件
          copy:
            dest: /etc/profile.d/rke2.sh
            content: |
              export PATH=$PATH:{{ rke2_data_dir }}/bin
            mode: 0644
        
        - name: 配置ctr命令和crictl
          lineinfile:
            path: /etc/profile
            line: 'alias ctr="{{ rke2_data_dir }}/bin/ctr --address /run/k3s/containerd/containerd.sock --namespace k8s.io"'
        
        - name: 配置CRI_CONFIG_FILE
          lineinfile:
            path: /etc/profile
            line: 'export CRI_CONFIG_FILE={{ rke2_data_dir }}/agent/etc/crictl.yaml'
        
        - name: 配置containerd.sock软链接
          copy:
            dest: /etc/tmpfiles.d/containerd-sock.conf
            content: 'L /run/containerd/containerd.sock - - - - /run/k3s/containerd/containerd.sock'
        
        - name: 使配置立即生效
          shell: systemd-tmpfiles --create /etc/tmpfiles.d/containerd-sock.conf
        
        - name: 验证软链接
          shell: ls -la /run/containerd/
          register: symlink_check
          changed_when: false
        
        - name: 显示软链接状态
          debug:
            msg: "{{ symlink_check.stdout_lines }}"
    
    - name: 显示worker节点安装完成信息
      debug:
        msg: "Worker节点 {{ inventory_hostname }} 安装完成!"
